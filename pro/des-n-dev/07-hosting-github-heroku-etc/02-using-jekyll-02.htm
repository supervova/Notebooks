<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Блог на Jekyll и Go</title>
<link href="/a/css/styles.css" rel="stylesheet" type="text/css" />
</head>

<body>
<h1>Блог на Jekyll и Go</h1>
<p>В Jekyll посты пишутся с использованием разметки Markdown или Textile (надо проверить на предмет HTML). Также можно добавлять в проект произвольные файлы, которые при генерации сайта будут выкладываться без изменений. По сути — это движок сайта, в котором еще можно некоторые файлы оформлять в виде блога.</p>
<p>Комментарии же, как основная &ldquo;динамика&rdquo; блога, может реализоваться через, например, <a href="http://disqus.com">Disqus</a>. К слову сказать, есть эстэты статических блогов с высшей степенью дзэна — со <em>статическими комментариями</em> (для меня даже это словосочетание является оксюмороном). Подход тут такой: у поста внизу есть секция со <em>статически</em> выведенными ранее введенными комментариями, и рядом форма для ввода нового. Ты вводишь комментарий, и он отсылается автору блога. Тот его подтверждает (или нет), куда-то кликает, и комментарий помещается в виде файла в статический проект блога, все пересобирается и выкладывается на публику. Понятно, что это никакой ни разу не real-time, а больше похоже на комментарии с пре-модерированием, причем модератор выходит на связь раз в неделю.</p>
<p>Я очень ценю дискуссию, и подобный подход не для меня. И продолжаю использовать Disqus. Кстати, из Disqus можно прекрасно экспортировать базу комментариев, и, например, превратить ее в статические страницы, если вдруг придется с него уходить.</p>
<p>Но вернемся к Jekyll. Например, github Pages напрямую поддерживает Jekyll (его автор и есть сооснователь github) и умеет рендерить проекты Jekyll (хотя можно и рендерить самому локально). Заливаешь через git проект Jekyll, и сайт становится видимым в github Pages.</p>
<p>На Heroku идея немного иная. Heroku хостит Ruby, поэтому статический сайт на Heroku — это сами страницы и программа-вебсервер, которая их отдает. Звучит страшновато, но на Ruby такой сервер выглядит весьма компактно, например так:</p>
<pre>
require 'bundler/setup'
require 'sinatra/base'

class SinatraStaticServer &lt; Sinatra::Base  

  get(/.+/) do
    send_sinatra_file(request.path) {404}
  end

  def send_sinatra_file(path, &amp;missing_file_block)
    file_path = File.join(File.dirname(__FILE__), 'public',  path)
    file_path = File.join(file_path, 'index.html') unless file_path =~ /\.[a-z]+$/i  
    File.exist?(file_path) ? send_file(file_path) : missing_file_block.call
  end
end

run SinatraStaticServer
</pre>
<p>Как ни странно, хостинг на Heroku в целом проще, чем на github. Также, на Heroku, git-репозиторий блога остается private, тогда как на github&rsquo;е он становиться открытым, как и все остальные проекты. Хотя для меня звучит странно держать проект блога (фактически, сайта) закрытым. Он же и так весь доступен через веб.</p>
<p>Да, и github Pages и Heroku позволяют &ldquo;прикрутить&rdquo; нормальный домен второго уровня, если у вас есть таковой.</p>
<p>Итак, я выбрал Jekyll c хостингом на Heroku. Увы, если взять чистый Jekyll, то придется самому с нуля разрабатывать стили и макет страниц. Если этим заниматься лень, то можно взять <a href="http://octopress.org/">Octopress</a>.</p>
<p>Octopress — это статический движок блога на базе Jekyll, но который укомплектован красивым HTML5 макетом страниц, пачкой удобных плагинов и автоматизированной возможностью выкладывания блога на github Pages и Heroku.</p>
<p>Итак, я взял Octopress, покрутил туда-сюда, попробовал несколько постов, протестировал рендеринг блога локально, повыкладывал на Heroku и github Pages. Все вроде было на мази.</p>
<p>Далее была самая нудная часть марлезонского балета — перетаскивание постов из любимого Блогспота. Фактически приходилось это делать вручную через cut-and-paste. Недели три мучений, и свои несчастные триста постов я обработал.</p>
<p>Все было готово для запуска моего нового статического блога. Но тут меня ждало главное разочарование. Драгоценный Jekyll, написанный на Ruby, рендерил мои несчастные триста постов (внимание!) — 15 минут (на Mac Air). А как сами понимаете, по началу надо было много пробовать, пересобирать, снова пробовать, снова пересобирать и т.д. И такое время полной пересборки не лезло ни в какие ворота.</p>
<p>Методом тыка я нашел узкое место в движке Jekyll/Octopress — львиная доля этих 15 минут уходило на генерацию файла <code>atom.xml</code>, RSS-фида. Почему-то в изначальных шаблонах в этот RSS-файл включалось только последние двадцать постов. Но у меня блог небольшой, поэтому я включил туда все посты, и тогда время генерации этого файла приводилось к пятнадцати минутной сборке всего блога.</p>
<p>Все это показалось мне каким-то абсурдом (при всей моей любви к Ruby). После небольшого размышления (я к тому времени уже более менее понимал внутренности Jekyll) и нежелания корячить Jekyll в попытках его ускорить, я задался вопросом — а не написать ли мне свой статический движок по схожей идее? Ведь это всего-навсего работа с файлами, текстом и, возможно, шаблонами. К тому же, в Jekyll нет многоязычности ни в каком виде, и у меня были планы туда ее добавить, но с собственным движком у меня полностью развязаны руки, и можно сделать все стройно и красиво.</p>
<p>На чем писать? Можно по-мужски: на C++/boost. Будет работать очень быстро, но скучно. Я решил на Go. Нативная, очень быстрая компиляция (фактически, у меня нет фазы компиляции, так как она совмещена с фазой запуска), удобная работа со строками и файловой системой, упрощенная работа с памятью (сборщик мусора), регулярные выражения, массивы, хэши, библиотека шаблонов, <a href="https://github.com/russross/blackfriday">библиотека для Markdown</a>. Все, кроме последнего, &ldquo;из коробки&rdquo;. Каких-либо проблем с производительностью не должно быть вообще. Тут как раз вышел релиз Go 1, и теперь есть нормальные дистрибутивы под Windows и Mac.</p>
<p>Итак, после трех вечеров родился мой велосипед — <a href="https://github.com/begoon/begoon.github.com">Goblog</a>. Весь проект открытый. Сайт и его исходные тексты находятся вместе.</p>
<h2>Принцип работы</h2>
<p>Есть два основных места: проект и собранный сайт-блог. В первом лежат исходные файлы. В процессе сборки файлы из проекта копируется в собранный сайт с сохранением локальной структуры каталогов. По умолчанию файлы копируются без изменений, как двоичные. Если же какой-то файл имеет расширение <code>html</code>, <code>xml</code> или <code>js</code>, то этот файл прогоняется через <a href="http://weekly.golang.org/pkg/text/template/">систему шаблонов Go</a>. Файлы с расширением <code>markdown</code> дополнительно перед шаблонами обрабатываются <a href="https://github.com/russross/blackfriday">библиотекой Markdown</a>.</p>
<p>Каталоги:</p>
<ul>
<li><code>&lt;root&gt;</code> — Здесь находится собранный сайт, как он видится по адресу <a href="http://demin.ws/">http://demin.ws/</a>.</li>
<li><code>&lt;root&gt;/_engine</code> — Это проект, тут лежат исходники и генератор сайта. Технически, этот каталог <a href="http://demin.ws/_engine/">виден и через web</a>.</li>
</ul>
<p>Подкаталоги и файлы в каталоге <code>_engine</code>:</p>
<ul>
<li>
<p><code>_includes</code> — Файлы, которые можно подставлять через макрос <code>&#123;{include &ldquo;filename&rdquo;}}</code>.</p>
</li>
<li>
<p><code>_layouts</code> — Файлы-layout&rsquo;ы (см. ниже).</p>
</li>
<li>
<p><code>_site</code> — Собственно, каталоги и файлы сайта. Этот каталог является корнем будущего сайта. Файлы из него при сборке перекладываются в собранный сайт. Некоторые обрабатываются шаблонами.</p>
</li>
<li>
<p><code>_posts</code> — Исходники постов. Эти файлы обрабатываются особо. Помимо шаблонов, они файлы переименовываются по структуре блога, где дата является частью URL: <code>домен/blog/язык/год/месяц/день/название-поста/</code></p>
</li>
</ul>
<p>Посты — это Markdown-файлы, имеющие особый заголовок и имя. Данные файлы выкладываются в отдельный каталог <code>/blog</code> с подкаталогами-датами. Информация о постах собирается в специальные переменные, которые делаются видимыми из шаблонов. Также по постам <a href="https://github.com/begoon/begoon.github.com/blob/9f088a83e86e54112696dd3954681b0450f40d91/_engine/main.go#L601">строится обратный индекс</a> для поиска.</p>
<h2>Layouts</h2>
<p>Идея layouts унаследована из Jekyll. Если пост или страница имеет в заголовке атрибут <code>layout</code> (<a href="https://raw.github.com/begoon/begoon.github.com/master/_engine/_posts/russian/2009-01-24-why-i-have-started-this-blog.markdown">например</a>), то для ее рендеринга загружается указанный шаблон-layout (из каталога <code>_layouts</code>), тело поста или страницы вставляется в определенное место layout&rsquo;а (у меня это плейсхолдер <code>Page.child</code>), и затем все рендерится вместе. Это позволяет единообразно оформлять группы схожих страниц (например, постов). Layout&rsquo;ы могут быть вложенные.</p>
<h2>Генератор</h2>
<p>И теперь, собственно, генератор — <a href="https://github.com/begoon/begoon.github.com/blob/master/_engine/main.go">main.go</a>.</p>
<p>Все, что я делаю для сборки (в каталоге <code>_engine</code>), это:</p>
<pre>make
</pre>
<p>Выводится примерно следующее:</p>
<pre>_engine$ make
gofmt -w=true -tabs=false -tabwidth=2 main.go
go run main.go 
Go static blog generator  Copyright (C) 2012 by Alexander Demin
Words in russian index: 18452
Words in english index: 3563
15.672979s
Processed 344 posts.
</pre>
<p>Если все хорошо, то в корне проекта (в каталоге <code>..</code> относительно <code>_engine</code>) образуются файлы, готовые для выкладки. На моем Mac Air сборка занимает 15 секунд (привет, Jekyll/Octopress, и до свидания). Tак как все находится под git, то всегда четко видно, где и какие файлы появились, исчезли или изменились.</p>
<p>Далее можно проверить сайт локально (см. ниже).</p>
<p>Если все готово, можно добавить измененные файлы (как исходники из <code>_site/</code>, так и собранные файлы) в локальный репозиторий:</p>
<pre>git add ../*
git commit -m &quot;New post about ...&quot;
</pre>
<p>И выложить на github Pages:</p>
<pre>git push
</pre>
<p>Практически сразу после <code>push</code> файлы появляются на <a href="http://demin.ws/">demin.ws</a>.</p>
<p>В <a href="https://github.com/begoon/begoon.github.com/blob/master/_engine/Makefile">Makefile</a> несколько дополнительных команд для облегчения жизни.</p>
<h2>Локальное тестирование</h2>
<p>Чтобы запустить сайт локально, я временно добавляю <code>127.0.0.1 demin.ws</code> в <code>/etc/hosts</code> и запускаю мини web-сервер. Помните, как он выглядел на Ruby? Маленький, правда? А теперь версия на Go (<a href="https://github.com/begoon/begoon.github.com/blob/master/_engine/server.go">server.go</a>):</p>
<pre>
package main
import &quot;net/http&quot;
func main() {
  panic(http.ListenAndServe(&quot;:80&quot;, http.FileServer(http.Dir(&quot;..&quot;))))
}
</pre>
<p>Итак:</p>
<pre>go run server.go&amp;
</pre>
<p>И можно тестировать сайт локально (возможно придется запустить через <code>sudo</code>, чтобы &ldquo;сесть&rdquo; на 80-й порт).</p>
<p>В принципе, можно и не трогать <code>/etc/hosts</code> и использовать адрес <code>localhost:80</code>, но RSS-фид файл <code>atom.xml</code> содержит абсолютные ссылки c доменом, поэтому для если надо тестировать RSS, то без подмены адреса не обойтись.</p>
<h2>Подсветка синтаксиса</h2>
<p>В качестве расширения Markdown у меня есть специальный тег для вставки блоков кода:</p>
<pre>{% codeblock lang:xxx %}
...
{% endcodeblock %}
</pre>
<p>Я унаследовал этот тег из Octopress&rsquo;a. Markdown уже имеет синтаксис для кода:</p>
<pre>``` xxx
...
```
</pre>
<p>где <code>xxx</code> — язык.</p>
<p>Но свой тег позволяет мне проще добавлять атрибуты, например, включение отображения номеров строк, преобразование табуляций и т.д.</p>
<p>Далее надо было решить вопрос подсветки синтаксиса. Я покрутил несколько онлайновых библиотек, которые через JavaScript раскрашивают прямо на странице, но в каждой была какая-то минимальная проблема, поэтому я таки решил раскрашивать код статически.</p>
<p>Первое, что пришло в голову — <a href="http://pygments.org/">pygments</a>. Все бы хорошо, но благодаря Питону, работает крайне медленно. Время полной сборки сайта с 15 секунд выросло до двух минут. Основное время тратилось на раскраску кода. Приходили мысли на тему кеша уже раскрашенных фрагментов и прочей ерунде, но после небольшого поиска проблема решилась радикально.</p>
<p>Надо было просто взять колоризатор, написанный на правильном для данной задачи языке. Отыскались две альтернативы: <a href="http://www.gnu.org/software/src-highlite/">GNU Source-highlight</a> и <a href="http://www.andre-simon.de/doku/highlight/en/highlight.html">Highlight</a>. Обе написаны на C++, поэтому работают практически мгновенно.</p>
<p>Например, вот тут <a href="http://petereisentraut.blogspot.co.uk/2009/07/adding-color-to-console-pygments-vs.html">человек сравнивал производительность pygments и syntax-highlight</a>.</p>
<p>Мне больше понравился Highlight. В нем языков больше поддерживается (например, в GNU&rsquo;шном даже Go нет). После перехода на Highlight время полной сборки вернулось к ~15-16 секундам, и я удовлетворился.</p>
<p>Вызов колоризатора сделан через обратный вызов в регулярном выражении, которое обрабатывает тег <code>{% codeblock %}</code> (функция <a href="https://github.com/begoon/begoon.github.com/blob/9f088a83e86e54112696dd3954681b0450f40d91/_engine/main.go#L656">highlight()</a>).</p>
<h2>Редакторы для Markdown</h2>
<p>Полно редакторов с preview для Markdown. Я использую <a href="http://markdownpad.com/">MarkdownPad</a> под Windows, и <a href="http://markedapp.com/">Marked</a> на Маке.</p>
<h2>Теги (категории) постов</h2>
<p>Я решил не делать теги вообще. Основываясь на собственном опыте, я понял, что никогда не пользуюсь тегами ни в своем блоге, ни в чужих. К тому же со временем взгляды на логику категоризации информации меняются, и порой приходится просто для совместимости с прошлым расставлять теги, в которых уже не видишь смысла. Какой, например, смысл в теге <code>c++</code> в моем блоге? Кто-нибудь когда-нибудь его использовал?</p>
<p>Но минимализм — это не путь к усложнению жизни. Наоборот. Лично я постоянно что-то ищу у себя в блоге в старых постах. На Блогспоте я просто заходил на главную страницу, жал &#8984;-F (ой, простите, CTRL-F) и искал по фрагментам слов в заголовках. Именно для этого я с некоторого в правой колонке стал выводить ссылки практически на все информативные посты.</p>
<p>В новом блоге все &ldquo;работает&rdquo; точно также прямо на первой странице с каталогом постов. При переносе постов я изменил заголовки некоторых, сделав их более информативными и пригодными для поиска.</p>
<p>Но! Все это уже не важно, так как теперь в блоге <a href="/blog/russian/2012/04/10/search-in-this-blog/">работает полнофункциональный контекстный поиск</a>.</p>
<h2>Проверки</h2>
<p>Одним из досадных неудобств Jekyll — это отстуствие каких-либо проверок чего-либо. А я прошел через это в полной мере в процессе перетаскивания постов из Блогспота. Битые ссылки, неверные даты, забытые кавычки, непроставленные языки и прочие атрибуты постов и многое другое. Поэтому Goblog везде где только можно проверяет все — форматы, ссылки, семантику и т.д. Если где-то ошибка, сборка останавливается. Когда я добавил функцию <a href="https://github.com/begoon/begoon.github.com/blob/9f088a83e86e54112696dd3954681b0450f40d91/_engine/main.go#L581">check_links()</a>, которая проверяет все локальные ссылки по всем файлам в уже собранном сайте, я выловил изрядное количество &ldquo;дохлых&rdquo; ссылок.</p>
<h2>Два языка</h2>
<p>Была еще проблема, которую, как мне кажется, удалось решить весьма элегантно: двуязычность. Мне нужен блог и сайт на двух языках. Но хардкодить &ldquo;прозрачную&rdquo; поддержку русского и английского как-то не хотелось, к тому же версии на разных языках могу радикально отличаться, и мне не сложно поддерживать их шаблоны независимо. В итоге, у меня есть просто понятие языка у каждого обрабатываемого файла (или поста), заданное в заголовке. Goblog не знает о языках. Он просто делает информацию о языке файла или поста доступной через шаблоны. А я уж сам решаю, где лежат какие файлы. Например, все русское лежит, начиная с корня сайта, а все английское имеет префикс <code>/english</code>.</p>
<p>Например, <a href="https://github.com/begoon/begoon.github.com/blob/master/_engine/_site/index.html">русская титульная страница</a> и <a href="https://github.com/begoon/begoon.github.com/blob/master/_engine/_site/english/index.html">английская титульная страница</a>.</p>
<h2>Чем я таки не доволен</h2>
<p>Я не люблю web-программирование: javascript, css, html, или web-дизайн, чего вообще делать не умею. Но тут мне таки пришлось покопаться в этом (с Octopress&rsquo;ом было проще). Я за основу взял <a href="http://tom.preston-werner.com/">сайт автора Jekyll</a>. Сделал все минималистично просто. К тому же все равно большинство людей читают через RSS и ходят на сайт только если хотят оставить комментарий. Следовательно, надо чтобы работал RSS и страничка поста была удобной (что для меня значит простой, без изощренных шрифтов и странного форматирования) для чтения.</p>
<h2>Мораль</h2>
<p>Вы думаете, я сейчас буду убеждать использовать мой движок? Совсем нет. Хоть я старался сделать движок максимально гибким и непривязанным конкретно к моему блогу, но мне пришлось переносить старые посты и их комментарии, поддержать два языка и т.д. В итоге в коде есть куски, &ldquo;заточенные&rdquo; конкретно под мой блог (особенно в области Disqus-ссылок на комментарии к старым постам).</p>
<p>Только могу порекомендовать, это что статический движок персонального сайта/блога можно написать самому. Почему? А потому, что эта задача решается за несколько вечеров (раз), и в нем будет только то, что вам реально нужно (остальное вам будет лень программировать) (два). Уверен, что все можно было сделать и на Руби, и на Питоне, PHP и т.д. Но было глупо упускать возможность поупражняться на новом языке с реальной задачей.</p>
</body>
</html>